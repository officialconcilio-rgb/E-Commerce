"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/fast-equals";
exports.ids = ["vendor-chunks/fast-equals"];
exports.modules = {

/***/ "(ssr)/../../node_modules/fast-equals/dist/es/index.mjs":
/*!********************************************************!*\
  !*** ../../node_modules/fast-equals/dist/es/index.mjs ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   circularDeepEqual: () => (/* binding */ circularDeepEqual),\n/* harmony export */   circularShallowEqual: () => (/* binding */ circularShallowEqual),\n/* harmony export */   createCustomEqual: () => (/* binding */ createCustomEqual),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual),\n/* harmony export */   sameValueZeroEqual: () => (/* binding */ sameValueZeroEqual),\n/* harmony export */   shallowEqual: () => (/* binding */ shallowEqual),\n/* harmony export */   strictCircularDeepEqual: () => (/* binding */ strictCircularDeepEqual),\n/* harmony export */   strictCircularShallowEqual: () => (/* binding */ strictCircularShallowEqual),\n/* harmony export */   strictDeepEqual: () => (/* binding */ strictDeepEqual),\n/* harmony export */   strictShallowEqual: () => (/* binding */ strictShallowEqual)\n/* harmony export */ });\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst { hasOwnProperty } = Object.prototype;\n/**\n * Combine two comparators into a single comparators.\n */ function combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n        return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n}\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */ function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n        if (!a || !b || typeof a !== \"object\" || typeof b !== \"object\") {\n            return areItemsEqual(a, b, state);\n        }\n        const { cache } = state;\n        const cachedA = cache.get(a);\n        const cachedB = cache.get(b);\n        if (cachedA && cachedB) {\n            return cachedA === b && cachedB === a;\n        }\n        cache.set(a, b);\n        cache.set(b, a);\n        const result = areItemsEqual(a, b, state);\n        cache.delete(a);\n        cache.delete(b);\n        return result;\n    };\n}\n/**\n * Get the `@@toStringTag` of the value, if it exists.\n */ function getShortTag(value) {\n    return value != null ? value[Symbol.toStringTag] : undefined;\n}\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */ function getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Whether the object contains the property passed as an own property.\n */ const hasOwn = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\nObject.hasOwn || ((object, property)=>hasOwnProperty.call(object, property));\n/**\n * Whether the values passed are strictly equal or both NaN.\n */ function sameValueZeroEqual(a, b) {\n    return a === b || !a && !b && a !== a && b !== b;\n}\nconst PREACT_VNODE = \"__v\";\nconst PREACT_OWNER = \"__o\";\nconst REACT_OWNER = \"_owner\";\nconst { getOwnPropertyDescriptor, keys } = Object;\n/**\n * Whether the array buffers are equal in value.\n */ function areArrayBuffersEqual(a, b) {\n    return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));\n}\n/**\n * Whether the arrays are equal in value.\n */ function areArraysEqual(a, b, state) {\n    let index = a.length;\n    if (b.length !== index) {\n        return false;\n    }\n    while(index-- > 0){\n        if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the dataviews are equal in value.\n */ function areDataViewsEqual(a, b) {\n    return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));\n}\n/**\n * Whether the dates passed are equal in value.\n */ function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n/**\n * Whether the errors passed are equal in value.\n */ function areErrorsEqual(a, b) {\n    return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;\n}\n/**\n * Whether the functions passed are equal in value.\n */ function areFunctionsEqual(a, b) {\n    return a === b;\n}\n/**\n * Whether the `Map`s are equal in value.\n */ function areMapsEqual(a, b, state) {\n    const size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    const matchedIndices = new Array(size);\n    const aIterable = a.entries();\n    let aResult;\n    let bResult;\n    let index = 0;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        const bIterable = b.entries();\n        let hasMatch = false;\n        let matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (matchedIndices[matchIndex]) {\n                matchIndex++;\n                continue;\n            }\n            const aEntry = aResult.value;\n            const bEntry = bResult.value;\n            if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n        index++;\n    }\n    return true;\n}\n/**\n * Whether the numbers are equal in value.\n */ const areNumbersEqual = sameValueZeroEqual;\n/**\n * Whether the objects are equal in value.\n */ function areObjectsEqual(a, b, state) {\n    const properties = keys(a);\n    let index = properties.length;\n    if (keys(b).length !== index) {\n        return false;\n    }\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        if (!isPropertyEqual(a, b, state, properties[index])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the objects are equal in value with strict property checking.\n */ function areObjectsEqualStrict(a, b, state) {\n    const properties = getStrictProperties(a);\n    let index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n        return false;\n    }\n    let property;\n    let descriptorA;\n    let descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while(index-- > 0){\n        property = properties[index];\n        if (!isPropertyEqual(a, b, state, property)) {\n            return false;\n        }\n        descriptorA = getOwnPropertyDescriptor(a, property);\n        descriptorB = getOwnPropertyDescriptor(b, property);\n        if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the primitive wrappers passed are equal in value.\n */ function arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n/**\n * Whether the regexps passed are equal in value.\n */ function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n}\n/**\n * Whether the `Set`s are equal in value.\n */ function areSetsEqual(a, b, state) {\n    const size = a.size;\n    if (size !== b.size) {\n        return false;\n    }\n    if (!size) {\n        return true;\n    }\n    const matchedIndices = new Array(size);\n    const aIterable = a.values();\n    let aResult;\n    let bResult;\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while(aResult = aIterable.next()){\n        if (aResult.done) {\n            break;\n        }\n        const bIterable = b.values();\n        let hasMatch = false;\n        let matchIndex = 0;\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        while(bResult = bIterable.next()){\n            if (bResult.done) {\n                break;\n            }\n            if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {\n                hasMatch = matchedIndices[matchIndex] = true;\n                break;\n            }\n            matchIndex++;\n        }\n        if (!hasMatch) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the TypedArray instances are equal in value.\n */ function areTypedArraysEqual(a, b) {\n    let index = a.byteLength;\n    if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {\n        return false;\n    }\n    while(index-- > 0){\n        if (a[index] !== b[index]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Whether the URL instances are equal in value.\n */ function areUrlsEqual(a, b) {\n    return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;\n}\nfunction isPropertyEqual(a, b, state, property) {\n    if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {\n        return true;\n    }\n    return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);\n}\nconst ARRAY_BUFFER_TAG = \"[object ArrayBuffer]\";\nconst ARGUMENTS_TAG = \"[object Arguments]\";\nconst BOOLEAN_TAG = \"[object Boolean]\";\nconst DATA_VIEW_TAG = \"[object DataView]\";\nconst DATE_TAG = \"[object Date]\";\nconst ERROR_TAG = \"[object Error]\";\nconst MAP_TAG = \"[object Map]\";\nconst NUMBER_TAG = \"[object Number]\";\nconst OBJECT_TAG = \"[object Object]\";\nconst REG_EXP_TAG = \"[object RegExp]\";\nconst SET_TAG = \"[object Set]\";\nconst STRING_TAG = \"[object String]\";\nconst TYPED_ARRAY_TAGS = {\n    \"[object Int8Array]\": true,\n    \"[object Uint8Array]\": true,\n    \"[object Uint8ClampedArray]\": true,\n    \"[object Int16Array]\": true,\n    \"[object Uint16Array]\": true,\n    \"[object Int32Array]\": true,\n    \"[object Uint32Array]\": true,\n    \"[object Float16Array]\": true,\n    \"[object Float32Array]\": true,\n    \"[object Float64Array]\": true,\n    \"[object BigInt64Array]\": true,\n    \"[object BigUint64Array]\": true\n};\nconst URL_TAG = \"[object URL]\";\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst toString = Object.prototype.toString;\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */ function createEqualityComparator({ areArrayBuffersEqual, areArraysEqual, areDataViewsEqual, areDatesEqual, areErrorsEqual, areFunctionsEqual, areMapsEqual, areNumbersEqual, areObjectsEqual, arePrimitiveWrappersEqual, areRegExpsEqual, areSetsEqual, areTypedArraysEqual, areUrlsEqual, unknownTagComparators }) {\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */ return function comparator(a, b, state) {\n        // If the items are strictly equal, no need to do a value comparison.\n        if (a === b) {\n            return true;\n        }\n        // If either of the items are nullish and fail the strictly equal check\n        // above, then they must be unequal.\n        if (a == null || b == null) {\n            return false;\n        }\n        const type = typeof a;\n        if (type !== typeof b) {\n            return false;\n        }\n        if (type !== \"object\") {\n            if (type === \"number\") {\n                return areNumbersEqual(a, b, state);\n            }\n            if (type === \"function\") {\n                return areFunctionsEqual(a, b, state);\n            }\n            // If a primitive value that is not strictly equal, it must be unequal.\n            return false;\n        }\n        const constructor = a.constructor;\n        // Checks are listed in order of commonality of use-case:\n        //   1. Common complex object types (plain object, array)\n        //   2. Common data values (date, regexp)\n        //   3. Less-common complex object types (map, set)\n        //   4. Less-common data values (promise, primitive wrappers)\n        // Inherently this is both subjective and assumptive, however\n        // when reviewing comparable libraries in the wild this order\n        // appears to be generally consistent.\n        // Constructors should match, otherwise there is potential for false positives\n        // between class and subclass or custom object and POJO.\n        if (constructor !== b.constructor) {\n            return false;\n        }\n        // `isPlainObject` only checks against the object's own realm. Cross-realm\n        // comparisons are rare, and will be handled in the ultimate fallback, so\n        // we can avoid capturing the string tag.\n        if (constructor === Object) {\n            return areObjectsEqual(a, b, state);\n        }\n        // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n        // the string tag or doing an `instanceof` check.\n        if (Array.isArray(a)) {\n            return areArraysEqual(a, b, state);\n        }\n        // Try to fast-path equality checks for other complex object types in the\n        // same realm to avoid capturing the string tag. Strict equality is used\n        // instead of `instanceof` because it is more performant for the common\n        // use-case. If someone is subclassing a native class, it will be handled\n        // with the string tag comparison.\n        if (constructor === Date) {\n            return areDatesEqual(a, b, state);\n        }\n        if (constructor === RegExp) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (constructor === Map) {\n            return areMapsEqual(a, b, state);\n        }\n        if (constructor === Set) {\n            return areSetsEqual(a, b, state);\n        }\n        // Since this is a custom object, capture the string tag to determing its type.\n        // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n        const tag = toString.call(a);\n        if (tag === DATE_TAG) {\n            return areDatesEqual(a, b, state);\n        }\n        // For RegExp, the properties are not enumerable, and therefore will give false positives if\n        // tested like a standard object.\n        if (tag === REG_EXP_TAG) {\n            return areRegExpsEqual(a, b, state);\n        }\n        if (tag === MAP_TAG) {\n            return areMapsEqual(a, b, state);\n        }\n        if (tag === SET_TAG) {\n            return areSetsEqual(a, b, state);\n        }\n        if (tag === OBJECT_TAG) {\n            // The exception for value comparison is custom `Promise`-like class instances. These should\n            // be treated the same as standard `Promise` objects, which means strict equality, and if\n            // it reaches this point then that strict equality comparison has already failed.\n            return typeof a.then !== \"function\" && typeof b.then !== \"function\" && areObjectsEqual(a, b, state);\n        }\n        // If a URL tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === URL_TAG) {\n            return areUrlsEqual(a, b, state);\n        }\n        // If an error tag, it should be tested explicitly. Like RegExp, the properties are not\n        // enumerable, and therefore will give false positives if tested like a standard object.\n        if (tag === ERROR_TAG) {\n            return areErrorsEqual(a, b, state);\n        }\n        // If an arguments tag, it should be treated as a standard object.\n        if (tag === ARGUMENTS_TAG) {\n            return areObjectsEqual(a, b, state);\n        }\n        if (TYPED_ARRAY_TAGS[tag]) {\n            return areTypedArraysEqual(a, b, state);\n        }\n        if (tag === ARRAY_BUFFER_TAG) {\n            return areArrayBuffersEqual(a, b, state);\n        }\n        if (tag === DATA_VIEW_TAG) {\n            return areDataViewsEqual(a, b, state);\n        }\n        // As the penultimate fallback, check if the values passed are primitive wrappers. This\n        // is very rare in modern JS, which is why it is deprioritized compared to all other object\n        // types.\n        if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n            return arePrimitiveWrappersEqual(a, b, state);\n        }\n        if (unknownTagComparators) {\n            let unknownTagComparator = unknownTagComparators[tag];\n            if (!unknownTagComparator) {\n                const shortTag = getShortTag(a);\n                if (shortTag) {\n                    unknownTagComparator = unknownTagComparators[shortTag];\n                }\n            }\n            // If the custom config has an unknown tag comparator that matches the captured tag or the\n            // @@toStringTag, it is the source of truth for whether the values are equal.\n            if (unknownTagComparator) {\n                return unknownTagComparator(a, b, state);\n            }\n        }\n        // If not matching any tags that require a specific type of comparison, then we hard-code false because\n        // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n        //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n        //     comparison that can be made.\n        //   - For types that can be introspected, but rarely have requirements to be compared\n        //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n        //     use-cases (may be included in a future release, if requested enough).\n        //   - For types that can be introspected but do not have an objective definition of what\n        //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n        // In all cases, these decisions should be reevaluated based on changes to the language and\n        // common development practices.\n        return false;\n    };\n}\n/**\n * Create the configuration object used for building comparators.\n */ function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {\n    let config = {\n        areArrayBuffersEqual,\n        areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n        areDataViewsEqual,\n        areDatesEqual: areDatesEqual,\n        areErrorsEqual: areErrorsEqual,\n        areFunctionsEqual: areFunctionsEqual,\n        areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n        areNumbersEqual: areNumbersEqual,\n        areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n        arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n        areRegExpsEqual: areRegExpsEqual,\n        areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n        areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,\n        areUrlsEqual: areUrlsEqual,\n        unknownTagComparators: undefined\n    };\n    if (createCustomConfig) {\n        config = Object.assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n        const areArraysEqual = createIsCircular(config.areArraysEqual);\n        const areMapsEqual = createIsCircular(config.areMapsEqual);\n        const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n        const areSetsEqual = createIsCircular(config.areSetsEqual);\n        config = Object.assign({}, config, {\n            areArraysEqual,\n            areMapsEqual,\n            areObjectsEqual,\n            areSetsEqual\n        });\n    }\n    return config;\n}\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */ function createInternalEqualityComparator(compare) {\n    return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n        return compare(a, b, state);\n    };\n}\n/**\n * Create the `isEqual` function used by the consuming application.\n */ function createIsEqual({ circular, comparator, createState, equals, strict }) {\n    if (createState) {\n        return function isEqual(a, b) {\n            const { cache = circular ? new WeakMap() : undefined, meta } = createState();\n            return comparator(a, b, {\n                cache,\n                equals,\n                meta,\n                strict\n            });\n        };\n    }\n    if (circular) {\n        return function isEqual(a, b) {\n            return comparator(a, b, {\n                cache: new WeakMap(),\n                equals,\n                meta: undefined,\n                strict\n            });\n        };\n    }\n    const state = {\n        cache: undefined,\n        equals,\n        meta: undefined,\n        strict\n    };\n    return function isEqual(a, b) {\n        return comparator(a, b, state);\n    };\n}\n/**\n * Whether the items passed are deeply-equal in value.\n */ const deepEqual = createCustomEqual();\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */ const strictDeepEqual = createCustomEqual({\n    strict: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */ const circularDeepEqual = createCustomEqual({\n    circular: true\n});\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */ const strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true\n});\n/**\n * Whether the items passed are shallowly-equal in value.\n */ const shallowEqual = createCustomEqual({\n    createInternalComparator: ()=>sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */ const strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: ()=>sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */ const circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: ()=>sameValueZeroEqual\n});\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */ const strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: ()=>sameValueZeroEqual,\n    strict: true\n});\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */ function createCustomEqual(options = {}) {\n    const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options;\n    const config = createEqualityComparatorConfig(options);\n    const comparator = createEqualityComparator(config);\n    const equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n    return createIsEqual({\n        circular,\n        comparator,\n        createState,\n        equals,\n        strict\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZXF1YWxzL2Rpc3QvZXMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQSxNQUFNLEVBQUVBLG1CQUFtQixFQUFFQyxxQkFBcUIsRUFBRSxHQUFHQztBQUN2RCw2REFBNkQ7QUFDN0QsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0QsT0FBT0UsU0FBUztBQUMzQzs7Q0FFQyxHQUNELFNBQVNDLG1CQUFtQkMsV0FBVyxFQUFFQyxXQUFXO0lBQ2hELE9BQU8sU0FBU0MsUUFBUUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLEtBQUs7UUFDL0IsT0FBT0wsWUFBWUcsR0FBR0MsR0FBR0MsVUFBVUosWUFBWUUsR0FBR0MsR0FBR0M7SUFDekQ7QUFDSjtBQUNBOzs7O0NBSUMsR0FDRCxTQUFTQyxpQkFBaUJDLGFBQWE7SUFDbkMsT0FBTyxTQUFTQyxXQUFXTCxDQUFDLEVBQUVDLENBQUMsRUFBRUMsS0FBSztRQUNsQyxJQUFJLENBQUNGLEtBQUssQ0FBQ0MsS0FBSyxPQUFPRCxNQUFNLFlBQVksT0FBT0MsTUFBTSxVQUFVO1lBQzVELE9BQU9HLGNBQWNKLEdBQUdDLEdBQUdDO1FBQy9CO1FBQ0EsTUFBTSxFQUFFSSxLQUFLLEVBQUUsR0FBR0o7UUFDbEIsTUFBTUssVUFBVUQsTUFBTUUsR0FBRyxDQUFDUjtRQUMxQixNQUFNUyxVQUFVSCxNQUFNRSxHQUFHLENBQUNQO1FBQzFCLElBQUlNLFdBQVdFLFNBQVM7WUFDcEIsT0FBT0YsWUFBWU4sS0FBS1EsWUFBWVQ7UUFDeEM7UUFDQU0sTUFBTUksR0FBRyxDQUFDVixHQUFHQztRQUNiSyxNQUFNSSxHQUFHLENBQUNULEdBQUdEO1FBQ2IsTUFBTVcsU0FBU1AsY0FBY0osR0FBR0MsR0FBR0M7UUFDbkNJLE1BQU1NLE1BQU0sQ0FBQ1o7UUFDYk0sTUFBTU0sTUFBTSxDQUFDWDtRQUNiLE9BQU9VO0lBQ1g7QUFDSjtBQUNBOztDQUVDLEdBQ0QsU0FBU0Us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O0lBQ1ZxQiwwQkFBMEIsSUFBTXJIO0FBQ3BDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTXdILDZCQUE2QlIsa0JBQWtCO0lBQ2pEaEIsVUFBVTtJQUNWcUIsMEJBQTBCLElBQU1ySDtJQUNoQ2tHLFFBQVE7QUFDWjtBQUNBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTYyxrQkFBa0JTLFVBQVUsQ0FBQyxDQUFDO0lBQ25DLE1BQU0sRUFBRXpCLFdBQVcsS0FBSyxFQUFFcUIsMEJBQTBCSyw4QkFBOEIsRUFBRWQsV0FBVyxFQUFFVixTQUFTLEtBQUssRUFBRyxHQUFHdUI7SUFDckgsTUFBTXRCLFNBQVNKLCtCQUErQjBCO0lBQzlDLE1BQU10QyxhQUFhRix5QkFBeUJrQjtJQUM1QyxNQUFNdEYsU0FBUzZHLGlDQUNUQSwrQkFBK0J2QyxjQUMvQmtCLGlDQUFpQ2xCO0lBQ3ZDLE9BQU93QixjQUFjO1FBQUVYO1FBQVViO1FBQVl5QjtRQUFhL0Y7UUFBUXFGO0lBQU87QUFDN0U7QUFFNk0sQ0FDN00sa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGUtY29tbWVyY2UvYWRtaW4tcGFuZWwvLi4vLi4vbm9kZV9tb2R1bGVzL2Zhc3QtZXF1YWxzL2Rpc3QvZXMvaW5kZXgubWpzPzg1MmMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBnZXRPd25Qcm9wZXJ0eU5hbWVzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgfSA9IE9iamVjdDtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbmNvbnN0IHsgaGFzT3duUHJvcGVydHkgfSA9IE9iamVjdC5wcm90b3R5cGU7XG4vKipcbiAqIENvbWJpbmUgdHdvIGNvbXBhcmF0b3JzIGludG8gYSBzaW5nbGUgY29tcGFyYXRvcnMuXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVDb21wYXJhdG9ycyhjb21wYXJhdG9yQSwgY29tcGFyYXRvckIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvckEoYSwgYiwgc3RhdGUpICYmIGNvbXBhcmF0b3JCKGEsIGIsIHN0YXRlKTtcbiAgICB9O1xufVxuLyoqXG4gKiBXcmFwIHRoZSBwcm92aWRlZCBgYXJlSXRlbXNFcXVhbGAgbWV0aG9kIHRvIG1hbmFnZSB0aGUgY2lyY3VsYXIgc3RhdGUsIGFsbG93aW5nXG4gKiBmb3IgY2lyY3VsYXIgcmVmZXJlbmNlcyB0byBiZSBzYWZlbHkgaW5jbHVkZWQgaW4gdGhlIGNvbXBhcmlzb24gd2l0aG91dCBjcmVhdGluZ1xuICogc3RhY2sgb3ZlcmZsb3dzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVJc0NpcmN1bGFyKGFyZUl0ZW1zRXF1YWwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gaXNDaXJjdWxhcihhLCBiLCBzdGF0ZSkge1xuICAgICAgICBpZiAoIWEgfHwgIWIgfHwgdHlwZW9mIGEgIT09ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUl0ZW1zRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FjaGUgfSA9IHN0YXRlO1xuICAgICAgICBjb25zdCBjYWNoZWRBID0gY2FjaGUuZ2V0KGEpO1xuICAgICAgICBjb25zdCBjYWNoZWRCID0gY2FjaGUuZ2V0KGIpO1xuICAgICAgICBpZiAoY2FjaGVkQSAmJiBjYWNoZWRCKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQSA9PT0gYiAmJiBjYWNoZWRCID09PSBhO1xuICAgICAgICB9XG4gICAgICAgIGNhY2hlLnNldChhLCBiKTtcbiAgICAgICAgY2FjaGUuc2V0KGIsIGEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhcmVJdGVtc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGEpO1xuICAgICAgICBjYWNoZS5kZWxldGUoYik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbn1cbi8qKlxuICogR2V0IHRoZSBgQEB0b1N0cmluZ1RhZ2Agb2YgdGhlIHZhbHVlLCBpZiBpdCBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIGdldFNob3J0VGFnKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgPyB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIDogdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBHZXQgdGhlIHByb3BlcnRpZXMgdG8gc3RyaWN0bHkgZXhhbWluZSwgd2hpY2ggaW5jbHVkZSBib3RoIG93biBwcm9wZXJ0aWVzIHRoYXQgYXJlXG4gKiBub3QgZW51bWVyYWJsZSBhbmQgc3ltYm9sIHByb3BlcnRpZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0cmljdFByb3BlcnRpZXMob2JqZWN0KSB7XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KS5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3QgY29udGFpbnMgdGhlIHByb3BlcnR5IHBhc3NlZCBhcyBhbiBvd24gcHJvcGVydHkuXG4gKi9cbmNvbnN0IGhhc093biA9IFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bm5lY2Vzc2FyeS1jb25kaXRpb25cbk9iamVjdC5oYXNPd24gfHwgKChvYmplY3QsIHByb3BlcnR5KSA9PiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKTtcbi8qKlxuICogV2hldGhlciB0aGUgdmFsdWVzIHBhc3NlZCBhcmUgc3RyaWN0bHkgZXF1YWwgb3IgYm90aCBOYU4uXG4gKi9cbmZ1bmN0aW9uIHNhbWVWYWx1ZVplcm9FcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgfHwgKCFhICYmICFiICYmIGEgIT09IGEgJiYgYiAhPT0gYik7XG59XG5cbmNvbnN0IFBSRUFDVF9WTk9ERSA9ICdfX3YnO1xuY29uc3QgUFJFQUNUX09XTkVSID0gJ19fbyc7XG5jb25zdCBSRUFDVF9PV05FUiA9ICdfb3duZXInO1xuY29uc3QgeyBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsIGtleXMgfSA9IE9iamVjdDtcbi8qKlxuICogV2hldGhlciB0aGUgYXJyYXkgYnVmZmVycyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZUFycmF5QnVmZmVyc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5ieXRlTGVuZ3RoID09PSBiLmJ5dGVMZW5ndGggJiYgYXJlVHlwZWRBcnJheXNFcXVhbChuZXcgVWludDhBcnJheShhKSwgbmV3IFVpbnQ4QXJyYXkoYikpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBhcnJheXMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIGxldCBpbmRleCA9IGEubGVuZ3RoO1xuICAgIGlmIChiLmxlbmd0aCAhPT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5lcXVhbHMoYVtpbmRleF0sIGJbaW5kZXhdLCBpbmRleCwgaW5kZXgsIGEsIGIsIHN0YXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBkYXRhdmlld3MgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVEYXRhVmlld3NFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIChhLmJ5dGVMZW5ndGggPT09IGIuYnl0ZUxlbmd0aFxuICAgICAgICAmJiBhcmVUeXBlZEFycmF5c0VxdWFsKG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCksIG5ldyBVaW50OEFycmF5KGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIuYnl0ZUxlbmd0aCkpKTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgZGF0ZXMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlRGF0ZXNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIHNhbWVWYWx1ZVplcm9FcXVhbChhLmdldFRpbWUoKSwgYi5nZXRUaW1lKCkpO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBlcnJvcnMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlRXJyb3JzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhLm5hbWUgPT09IGIubmFtZSAmJiBhLm1lc3NhZ2UgPT09IGIubWVzc2FnZSAmJiBhLmNhdXNlID09PSBiLmNhdXNlICYmIGEuc3RhY2sgPT09IGIuc3RhY2s7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGZ1bmN0aW9ucyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVGdW5jdGlvbnNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGBNYXBgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZU1hcHNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIGNvbnN0IHNpemUgPSBhLnNpemU7XG4gICAgaWYgKHNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hlZEluZGljZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgYUl0ZXJhYmxlID0gYS5lbnRyaWVzKCk7XG4gICAgbGV0IGFSZXN1bHQ7XG4gICAgbGV0IGJSZXN1bHQ7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIHdoaWxlICgoYVJlc3VsdCA9IGFJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgIGlmIChhUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJJdGVyYWJsZSA9IGIuZW50cmllcygpO1xuICAgICAgICBsZXQgaGFzTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgbGV0IG1hdGNoSW5kZXggPSAwO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgICAgICB3aGlsZSAoKGJSZXN1bHQgPSBiSXRlcmFibGUubmV4dCgpKSkge1xuICAgICAgICAgICAgaWYgKGJSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hJbmRleCsrO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYUVudHJ5ID0gYVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGJFbnRyeSA9IGJSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICBpZiAoc3RhdGUuZXF1YWxzKGFFbnRyeVswXSwgYkVudHJ5WzBdLCBpbmRleCwgbWF0Y2hJbmRleCwgYSwgYiwgc3RhdGUpXG4gICAgICAgICAgICAgICAgJiYgc3RhdGUuZXF1YWxzKGFFbnRyeVsxXSwgYkVudHJ5WzFdLCBhRW50cnlbMF0sIGJFbnRyeVswXSwgYSwgYiwgc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgaGFzTWF0Y2ggPSBtYXRjaGVkSW5kaWNlc1ttYXRjaEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFoYXNNYXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4Kys7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBudW1iZXJzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuY29uc3QgYXJlTnVtYmVyc0VxdWFsID0gc2FtZVZhbHVlWmVyb0VxdWFsO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBvYmplY3RzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGtleXMoYSk7XG4gICAgbGV0IGluZGV4ID0gcHJvcGVydGllcy5sZW5ndGg7XG4gICAgaWYgKGtleXMoYikubGVuZ3RoICE9PSBpbmRleCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIERlY3JlbWVudGluZyBgd2hpbGVgIHNob3dlZCBmYXN0ZXIgcmVzdWx0cyB0aGFuIGVpdGhlciBpbmNyZW1lbnRpbmcgb3JcbiAgICAvLyBkZWNyZW1lbnRpbmcgYGZvcmAgbG9vcCBhbmQgdGhhbiBhbiBpbmNyZW1lbnRpbmcgYHdoaWxlYCBsb29wLiBEZWNsYXJhdGl2ZVxuICAgIC8vIG1ldGhvZHMgbGlrZSBgc29tZWAgLyBgZXZlcnlgIHdlcmUgbm90IHVzZWQgdG8gYXZvaWQgaW5jdXJyaW5nIHRoZSBnYXJiYWdlXG4gICAgLy8gY29zdCBvZiBhbm9ueW1vdXMgY2FsbGJhY2tzLlxuICAgIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgICAgICBpZiAoIWlzUHJvcGVydHlFcXVhbChhLCBiLCBzdGF0ZSwgcHJvcGVydGllc1tpbmRleF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIG9iamVjdHMgYXJlIGVxdWFsIGluIHZhbHVlIHdpdGggc3RyaWN0IHByb3BlcnR5IGNoZWNraW5nLlxuICovXG5mdW5jdGlvbiBhcmVPYmplY3RzRXF1YWxTdHJpY3QoYSwgYiwgc3RhdGUpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gZ2V0U3RyaWN0UHJvcGVydGllcyhhKTtcbiAgICBsZXQgaW5kZXggPSBwcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBpZiAoZ2V0U3RyaWN0UHJvcGVydGllcyhiKS5sZW5ndGggIT09IGluZGV4KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHByb3BlcnR5O1xuICAgIGxldCBkZXNjcmlwdG9yQTtcbiAgICBsZXQgZGVzY3JpcHRvckI7XG4gICAgLy8gRGVjcmVtZW50aW5nIGB3aGlsZWAgc2hvd2VkIGZhc3RlciByZXN1bHRzIHRoYW4gZWl0aGVyIGluY3JlbWVudGluZyBvclxuICAgIC8vIGRlY3JlbWVudGluZyBgZm9yYCBsb29wIGFuZCB0aGFuIGFuIGluY3JlbWVudGluZyBgd2hpbGVgIGxvb3AuIERlY2xhcmF0aXZlXG4gICAgLy8gbWV0aG9kcyBsaWtlIGBzb21lYCAvIGBldmVyeWAgd2VyZSBub3QgdXNlZCB0byBhdm9pZCBpbmN1cnJpbmcgdGhlIGdhcmJhZ2VcbiAgICAvLyBjb3N0IG9mIGFub255bW91cyBjYWxsYmFja3MuXG4gICAgd2hpbGUgKGluZGV4LS0gPiAwKSB7XG4gICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF07XG4gICAgICAgIGlmICghaXNQcm9wZXJ0eUVxdWFsKGEsIGIsIHN0YXRlLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBkZXNjcmlwdG9yQSA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLCBwcm9wZXJ0eSk7XG4gICAgICAgIGRlc2NyaXB0b3JCID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKChkZXNjcmlwdG9yQSB8fCBkZXNjcmlwdG9yQilcbiAgICAgICAgICAgICYmICghZGVzY3JpcHRvckFcbiAgICAgICAgICAgICAgICB8fCAhZGVzY3JpcHRvckJcbiAgICAgICAgICAgICAgICB8fCBkZXNjcmlwdG9yQS5jb25maWd1cmFibGUgIT09IGRlc2NyaXB0b3JCLmNvbmZpZ3VyYWJsZVxuICAgICAgICAgICAgICAgIHx8IGRlc2NyaXB0b3JBLmVudW1lcmFibGUgIT09IGRlc2NyaXB0b3JCLmVudW1lcmFibGVcbiAgICAgICAgICAgICAgICB8fCBkZXNjcmlwdG9yQS53cml0YWJsZSAhPT0gZGVzY3JpcHRvckIud3JpdGFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIHByaW1pdGl2ZSB3cmFwcGVycyBwYXNzZWQgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gc2FtZVZhbHVlWmVyb0VxdWFsKGEudmFsdWVPZigpLCBiLnZhbHVlT2YoKSk7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIHJlZ2V4cHMgcGFzc2VkIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlUmVnRXhwc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG59XG4vKipcbiAqIFdoZXRoZXIgdGhlIGBTZXRgcyBhcmUgZXF1YWwgaW4gdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSkge1xuICAgIGNvbnN0IHNpemUgPSBhLnNpemU7XG4gICAgaWYgKHNpemUgIT09IGIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2hlZEluZGljZXMgPSBuZXcgQXJyYXkoc2l6ZSk7XG4gICAgY29uc3QgYUl0ZXJhYmxlID0gYS52YWx1ZXMoKTtcbiAgICBsZXQgYVJlc3VsdDtcbiAgICBsZXQgYlJlc3VsdDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvblxuICAgIHdoaWxlICgoYVJlc3VsdCA9IGFJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgIGlmIChhUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJJdGVyYWJsZSA9IGIudmFsdWVzKCk7XG4gICAgICAgIGxldCBoYXNNYXRjaCA9IGZhbHNlO1xuICAgICAgICBsZXQgbWF0Y2hJbmRleCA9IDA7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5uZWNlc3NhcnktY29uZGl0aW9uXG4gICAgICAgIHdoaWxlICgoYlJlc3VsdCA9IGJJdGVyYWJsZS5uZXh0KCkpKSB7XG4gICAgICAgICAgICBpZiAoYlJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW1hdGNoZWRJbmRpY2VzW21hdGNoSW5kZXhdXG4gICAgICAgICAgICAgICAgJiYgc3RhdGUuZXF1YWxzKGFSZXN1bHQudmFsdWUsIGJSZXN1bHQudmFsdWUsIGFSZXN1bHQudmFsdWUsIGJSZXN1bHQudmFsdWUsIGEsIGIsIHN0YXRlKSkge1xuICAgICAgICAgICAgICAgIGhhc01hdGNoID0gbWF0Y2hlZEluZGljZXNbbWF0Y2hJbmRleF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzTWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogV2hldGhlciB0aGUgVHlwZWRBcnJheSBpbnN0YW5jZXMgYXJlIGVxdWFsIGluIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcmVUeXBlZEFycmF5c0VxdWFsKGEsIGIpIHtcbiAgICBsZXQgaW5kZXggPSBhLmJ5dGVMZW5ndGg7XG4gICAgaWYgKGIuYnl0ZUxlbmd0aCAhPT0gaW5kZXggfHwgYS5ieXRlT2Zmc2V0ICE9PSBiLmJ5dGVPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB3aGlsZSAoaW5kZXgtLSA+IDApIHtcbiAgICAgICAgaWYgKGFbaW5kZXhdICE9PSBiW2luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBXaGV0aGVyIHRoZSBVUkwgaW5zdGFuY2VzIGFyZSBlcXVhbCBpbiB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYXJlVXJsc0VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gKGEuaG9zdG5hbWUgPT09IGIuaG9zdG5hbWVcbiAgICAgICAgJiYgYS5wYXRobmFtZSA9PT0gYi5wYXRobmFtZVxuICAgICAgICAmJiBhLnByb3RvY29sID09PSBiLnByb3RvY29sXG4gICAgICAgICYmIGEucG9ydCA9PT0gYi5wb3J0XG4gICAgICAgICYmIGEuaGFzaCA9PT0gYi5oYXNoXG4gICAgICAgICYmIGEudXNlcm5hbWUgPT09IGIudXNlcm5hbWVcbiAgICAgICAgJiYgYS5wYXNzd29yZCA9PT0gYi5wYXNzd29yZCk7XG59XG5mdW5jdGlvbiBpc1Byb3BlcnR5RXF1YWwoYSwgYiwgc3RhdGUsIHByb3BlcnR5KSB7XG4gICAgaWYgKChwcm9wZXJ0eSA9PT0gUkVBQ1RfT1dORVIgfHwgcHJvcGVydHkgPT09IFBSRUFDVF9PV05FUiB8fCBwcm9wZXJ0eSA9PT0gUFJFQUNUX1ZOT0RFKVxuICAgICAgICAmJiAoYS4kJHR5cGVvZiB8fCBiLiQkdHlwZW9mKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc093bihiLCBwcm9wZXJ0eSkgJiYgc3RhdGUuZXF1YWxzKGFbcHJvcGVydHldLCBiW3Byb3BlcnR5XSwgcHJvcGVydHksIHByb3BlcnR5LCBhLCBiLCBzdGF0ZSk7XG59XG5cbmNvbnN0IEFSUkFZX0JVRkZFUl9UQUcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xuY29uc3QgQVJHVU1FTlRTX1RBRyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuY29uc3QgQk9PTEVBTl9UQUcgPSAnW29iamVjdCBCb29sZWFuXSc7XG5jb25zdCBEQVRBX1ZJRVdfVEFHID0gJ1tvYmplY3QgRGF0YVZpZXddJztcbmNvbnN0IERBVEVfVEFHID0gJ1tvYmplY3QgRGF0ZV0nO1xuY29uc3QgRVJST1JfVEFHID0gJ1tvYmplY3QgRXJyb3JdJztcbmNvbnN0IE1BUF9UQUcgPSAnW29iamVjdCBNYXBdJztcbmNvbnN0IE5VTUJFUl9UQUcgPSAnW29iamVjdCBOdW1iZXJdJztcbmNvbnN0IE9CSkVDVF9UQUcgPSAnW29iamVjdCBPYmplY3RdJztcbmNvbnN0IFJFR19FWFBfVEFHID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5jb25zdCBTRVRfVEFHID0gJ1tvYmplY3QgU2V0XSc7XG5jb25zdCBTVFJJTkdfVEFHID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5jb25zdCBUWVBFRF9BUlJBWV9UQUdTID0ge1xuICAgICdbb2JqZWN0IEludDhBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IFVpbnQ4QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEludDE2QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBVaW50MTZBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEludDMyQXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBVaW50MzJBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEZsb2F0MTZBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nOiB0cnVlLFxuICAgICdbb2JqZWN0IEJpZ0ludDY0QXJyYXldJzogdHJ1ZSxcbiAgICAnW29iamVjdCBCaWdVaW50NjRBcnJheV0nOiB0cnVlLFxufTtcbmNvbnN0IFVSTF9UQUcgPSAnW29iamVjdCBVUkxdJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8qKlxuICogQ3JlYXRlIGEgY29tcGFyYXRvciBtZXRob2QgYmFzZWQgb24gdGhlIHR5cGUtc3BlY2lmaWMgZXF1YWxpdHkgY29tcGFyYXRvcnMgcGFzc2VkLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IoeyBhcmVBcnJheUJ1ZmZlcnNFcXVhbCwgYXJlQXJyYXlzRXF1YWwsIGFyZURhdGFWaWV3c0VxdWFsLCBhcmVEYXRlc0VxdWFsLCBhcmVFcnJvcnNFcXVhbCwgYXJlRnVuY3Rpb25zRXF1YWwsIGFyZU1hcHNFcXVhbCwgYXJlTnVtYmVyc0VxdWFsLCBhcmVPYmplY3RzRXF1YWwsIGFyZVByaW1pdGl2ZVdyYXBwZXJzRXF1YWwsIGFyZVJlZ0V4cHNFcXVhbCwgYXJlU2V0c0VxdWFsLCBhcmVUeXBlZEFycmF5c0VxdWFsLCBhcmVVcmxzRXF1YWwsIHVua25vd25UYWdDb21wYXJhdG9ycywgfSkge1xuICAgIC8qKlxuICAgICAqIGNvbXBhcmUgdGhlIHZhbHVlIG9mIHRoZSB0d28gb2JqZWN0cyBhbmQgcmV0dXJuIHRydWUgaWYgdGhleSBhcmUgZXF1aXZhbGVudCBpbiB2YWx1ZXNcbiAgICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gY29tcGFyYXRvcihhLCBiLCBzdGF0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgaXRlbXMgYXJlIHN0cmljdGx5IGVxdWFsLCBubyBuZWVkIHRvIGRvIGEgdmFsdWUgY29tcGFyaXNvbi5cbiAgICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGVpdGhlciBvZiB0aGUgaXRlbXMgYXJlIG51bGxpc2ggYW5kIGZhaWwgdGhlIHN0cmljdGx5IGVxdWFsIGNoZWNrXG4gICAgICAgIC8vIGFib3ZlLCB0aGVuIHRoZXkgbXVzdCBiZSB1bmVxdWFsLlxuICAgICAgICBpZiAoYSA9PSBudWxsIHx8IGIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0eXBlb2YgYTtcbiAgICAgICAgaWYgKHR5cGUgIT09IHR5cGVvZiBiKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJlTnVtYmVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZUZ1bmN0aW9uc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIGEgcHJpbWl0aXZlIHZhbHVlIHRoYXQgaXMgbm90IHN0cmljdGx5IGVxdWFsLCBpdCBtdXN0IGJlIHVuZXF1YWwuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSBhLmNvbnN0cnVjdG9yO1xuICAgICAgICAvLyBDaGVja3MgYXJlIGxpc3RlZCBpbiBvcmRlciBvZiBjb21tb25hbGl0eSBvZiB1c2UtY2FzZTpcbiAgICAgICAgLy8gICAxLiBDb21tb24gY29tcGxleCBvYmplY3QgdHlwZXMgKHBsYWluIG9iamVjdCwgYXJyYXkpXG4gICAgICAgIC8vICAgMi4gQ29tbW9uIGRhdGEgdmFsdWVzIChkYXRlLCByZWdleHApXG4gICAgICAgIC8vICAgMy4gTGVzcy1jb21tb24gY29tcGxleCBvYmplY3QgdHlwZXMgKG1hcCwgc2V0KVxuICAgICAgICAvLyAgIDQuIExlc3MtY29tbW9uIGRhdGEgdmFsdWVzIChwcm9taXNlLCBwcmltaXRpdmUgd3JhcHBlcnMpXG4gICAgICAgIC8vIEluaGVyZW50bHkgdGhpcyBpcyBib3RoIHN1YmplY3RpdmUgYW5kIGFzc3VtcHRpdmUsIGhvd2V2ZXJcbiAgICAgICAgLy8gd2hlbiByZXZpZXdpbmcgY29tcGFyYWJsZSBsaWJyYXJpZXMgaW4gdGhlIHdpbGQgdGhpcyBvcmRlclxuICAgICAgICAvLyBhcHBlYXJzIHRvIGJlIGdlbmVyYWxseSBjb25zaXN0ZW50LlxuICAgICAgICAvLyBDb25zdHJ1Y3RvcnMgc2hvdWxkIG1hdGNoLCBvdGhlcndpc2UgdGhlcmUgaXMgcG90ZW50aWFsIGZvciBmYWxzZSBwb3NpdGl2ZXNcbiAgICAgICAgLy8gYmV0d2VlbiBjbGFzcyBhbmQgc3ViY2xhc3Mgb3IgY3VzdG9tIG9iamVjdCBhbmQgUE9KTy5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGlzUGxhaW5PYmplY3RgIG9ubHkgY2hlY2tzIGFnYWluc3QgdGhlIG9iamVjdCdzIG93biByZWFsbS4gQ3Jvc3MtcmVhbG1cbiAgICAgICAgLy8gY29tcGFyaXNvbnMgYXJlIHJhcmUsIGFuZCB3aWxsIGJlIGhhbmRsZWQgaW4gdGhlIHVsdGltYXRlIGZhbGxiYWNrLCBzb1xuICAgICAgICAvLyB3ZSBjYW4gYXZvaWQgY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnLlxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYGlzQXJyYXkoKWAgd29ya3Mgb24gc3ViY2xhc3NlcyBhbmQgaXMgY3Jvc3MtcmVhbG0sIHNvIHdlIGNhbiBhdm9pZCBjYXB0dXJpbmdcbiAgICAgICAgLy8gdGhlIHN0cmluZyB0YWcgb3IgZG9pbmcgYW4gYGluc3RhbmNlb2ZgIGNoZWNrLlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUFycmF5c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUcnkgdG8gZmFzdC1wYXRoIGVxdWFsaXR5IGNoZWNrcyBmb3Igb3RoZXIgY29tcGxleCBvYmplY3QgdHlwZXMgaW4gdGhlXG4gICAgICAgIC8vIHNhbWUgcmVhbG0gdG8gYXZvaWQgY2FwdHVyaW5nIHRoZSBzdHJpbmcgdGFnLiBTdHJpY3QgZXF1YWxpdHkgaXMgdXNlZFxuICAgICAgICAvLyBpbnN0ZWFkIG9mIGBpbnN0YW5jZW9mYCBiZWNhdXNlIGl0IGlzIG1vcmUgcGVyZm9ybWFudCBmb3IgdGhlIGNvbW1vblxuICAgICAgICAvLyB1c2UtY2FzZS4gSWYgc29tZW9uZSBpcyBzdWJjbGFzc2luZyBhIG5hdGl2ZSBjbGFzcywgaXQgd2lsbCBiZSBoYW5kbGVkXG4gICAgICAgIC8vIHdpdGggdGhlIHN0cmluZyB0YWcgY29tcGFyaXNvbi5cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0ZXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09PSBSZWdFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVSZWdFeHBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PT0gTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlTWFwc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29uc3RydWN0b3IgPT09IFNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVNldHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgdGhpcyBpcyBhIGN1c3RvbSBvYmplY3QsIGNhcHR1cmUgdGhlIHN0cmluZyB0YWcgdG8gZGV0ZXJtaW5nIGl0cyB0eXBlLlxuICAgICAgICAvLyBUaGlzIGlzIHJlYXNvbmFibHkgcGVyZm9ybWFudCBpbiBtb2Rlcm4gZW52aXJvbm1lbnRzIGxpa2UgdjggYW5kIFNwaWRlck1vbmtleS5cbiAgICAgICAgY29uc3QgdGFnID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICAgICAgaWYgKHRhZyA9PT0gREFURV9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVEYXRlc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3IgUmVnRXhwLCB0aGUgcHJvcGVydGllcyBhcmUgbm90IGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZlxuICAgICAgICAvLyB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gUkVHX0VYUF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVSZWdFeHBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IE1BUF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVNYXBzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IFNFVF9UQUcpIHtcbiAgICAgICAgICAgIHJldHVybiBhcmVTZXRzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YWcgPT09IE9CSkVDVF9UQUcpIHtcbiAgICAgICAgICAgIC8vIFRoZSBleGNlcHRpb24gZm9yIHZhbHVlIGNvbXBhcmlzb24gaXMgY3VzdG9tIGBQcm9taXNlYC1saWtlIGNsYXNzIGluc3RhbmNlcy4gVGhlc2Ugc2hvdWxkXG4gICAgICAgICAgICAvLyBiZSB0cmVhdGVkIHRoZSBzYW1lIGFzIHN0YW5kYXJkIGBQcm9taXNlYCBvYmplY3RzLCB3aGljaCBtZWFucyBzdHJpY3QgZXF1YWxpdHksIGFuZCBpZlxuICAgICAgICAgICAgLy8gaXQgcmVhY2hlcyB0aGlzIHBvaW50IHRoZW4gdGhhdCBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbiBoYXMgYWxyZWFkeSBmYWlsZWQuXG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGEudGhlbiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgYi50aGVuICE9PSAnZnVuY3Rpb24nICYmIGFyZU9iamVjdHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYSBVUkwgdGFnLCBpdCBzaG91bGQgYmUgdGVzdGVkIGV4cGxpY2l0bHkuIExpa2UgUmVnRXhwLCB0aGUgcHJvcGVydGllcyBhcmUgbm90XG4gICAgICAgIC8vIGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZiB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gVVJMX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZVVybHNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYW4gZXJyb3IgdGFnLCBpdCBzaG91bGQgYmUgdGVzdGVkIGV4cGxpY2l0bHkuIExpa2UgUmVnRXhwLCB0aGUgcHJvcGVydGllcyBhcmUgbm90XG4gICAgICAgIC8vIGVudW1lcmFibGUsIGFuZCB0aGVyZWZvcmUgd2lsbCBnaXZlIGZhbHNlIHBvc2l0aXZlcyBpZiB0ZXN0ZWQgbGlrZSBhIHN0YW5kYXJkIG9iamVjdC5cbiAgICAgICAgaWYgKHRhZyA9PT0gRVJST1JfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRXJyb3JzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIGFyZ3VtZW50cyB0YWcsIGl0IHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgc3RhbmRhcmQgb2JqZWN0LlxuICAgICAgICBpZiAodGFnID09PSBBUkdVTUVOVFNfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlT2JqZWN0c0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVFlQRURfQVJSQVlfVEFHU1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlVHlwZWRBcnJheXNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gQVJSQVlfQlVGRkVSX1RBRykge1xuICAgICAgICAgICAgcmV0dXJuIGFyZUFycmF5QnVmZmVyc0VxdWFsKGEsIGIsIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFnID09PSBEQVRBX1ZJRVdfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlRGF0YVZpZXdzRXF1YWwoYSwgYiwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFzIHRoZSBwZW51bHRpbWF0ZSBmYWxsYmFjaywgY2hlY2sgaWYgdGhlIHZhbHVlcyBwYXNzZWQgYXJlIHByaW1pdGl2ZSB3cmFwcGVycy4gVGhpc1xuICAgICAgICAvLyBpcyB2ZXJ5IHJhcmUgaW4gbW9kZXJuIEpTLCB3aGljaCBpcyB3aHkgaXQgaXMgZGVwcmlvcml0aXplZCBjb21wYXJlZCB0byBhbGwgb3RoZXIgb2JqZWN0XG4gICAgICAgIC8vIHR5cGVzLlxuICAgICAgICBpZiAodGFnID09PSBCT09MRUFOX1RBRyB8fCB0YWcgPT09IE5VTUJFUl9UQUcgfHwgdGFnID09PSBTVFJJTkdfVEFHKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbChhLCBiLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVua25vd25UYWdDb21wYXJhdG9ycykge1xuICAgICAgICAgICAgbGV0IHVua25vd25UYWdDb21wYXJhdG9yID0gdW5rbm93blRhZ0NvbXBhcmF0b3JzW3RhZ107XG4gICAgICAgICAgICBpZiAoIXVua25vd25UYWdDb21wYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2hvcnRUYWcgPSBnZXRTaG9ydFRhZyhhKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvcnRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5rbm93blRhZ0NvbXBhcmF0b3IgPSB1bmtub3duVGFnQ29tcGFyYXRvcnNbc2hvcnRUYWddO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXN0b20gY29uZmlnIGhhcyBhbiB1bmtub3duIHRhZyBjb21wYXJhdG9yIHRoYXQgbWF0Y2hlcyB0aGUgY2FwdHVyZWQgdGFnIG9yIHRoZVxuICAgICAgICAgICAgLy8gQEB0b1N0cmluZ1RhZywgaXQgaXMgdGhlIHNvdXJjZSBvZiB0cnV0aCBmb3Igd2hldGhlciB0aGUgdmFsdWVzIGFyZSBlcXVhbC5cbiAgICAgICAgICAgIGlmICh1bmtub3duVGFnQ29tcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmtub3duVGFnQ29tcGFyYXRvcihhLCBiLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgbm90IG1hdGNoaW5nIGFueSB0YWdzIHRoYXQgcmVxdWlyZSBhIHNwZWNpZmljIHR5cGUgb2YgY29tcGFyaXNvbiwgdGhlbiB3ZSBoYXJkLWNvZGUgZmFsc2UgYmVjYXVzZVxuICAgICAgICAvLyB0aGUgb25seSB0aGluZyByZW1haW5pbmcgaXMgc3RyaWN0IGVxdWFsaXR5LCB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGNvbXBhcmVkLiBUaGlzIGlzIGZvciBhIGZldyByZWFzb25zOlxuICAgICAgICAvLyAgIC0gQ2VydGFpbiB0eXBlcyB0aGF0IGNhbm5vdCBiZSBpbnRyb3NwZWN0ZWQgKGUuZy4sIGBXZWFrTWFwYCkuIEZvciB0aGVzZSB0eXBlcywgdGhpcyBpcyB0aGUgb25seVxuICAgICAgICAvLyAgICAgY29tcGFyaXNvbiB0aGF0IGNhbiBiZSBtYWRlLlxuICAgICAgICAvLyAgIC0gRm9yIHR5cGVzIHRoYXQgY2FuIGJlIGludHJvc3BlY3RlZCwgYnV0IHJhcmVseSBoYXZlIHJlcXVpcmVtZW50cyB0byBiZSBjb21wYXJlZFxuICAgICAgICAvLyAgICAgKGBBcnJheUJ1ZmZlcmAsIGBEYXRhVmlld2AsIGV0Yy4pLCB0aGUgY29zdCBpcyBhdm9pZGVkIHRvIHByaW9yaXRpemUgdGhlIGNvbW1vblxuICAgICAgICAvLyAgICAgdXNlLWNhc2VzIChtYXkgYmUgaW5jbHVkZWQgaW4gYSBmdXR1cmUgcmVsZWFzZSwgaWYgcmVxdWVzdGVkIGVub3VnaCkuXG4gICAgICAgIC8vICAgLSBGb3IgdHlwZXMgdGhhdCBjYW4gYmUgaW50cm9zcGVjdGVkIGJ1dCBkbyBub3QgaGF2ZSBhbiBvYmplY3RpdmUgZGVmaW5pdGlvbiBvZiB3aGF0XG4gICAgICAgIC8vICAgICBlcXVhbGl0eSBpcyAoYEVycm9yYCwgZXRjLiksIHRoZSBzdWJqZWN0aXZlIGRlY2lzaW9uIGlzIHRvIGJlIGNvbnNlcnZhdGl2ZSBhbmQgc3RyaWN0bHkgY29tcGFyZS5cbiAgICAgICAgLy8gSW4gYWxsIGNhc2VzLCB0aGVzZSBkZWNpc2lvbnMgc2hvdWxkIGJlIHJlZXZhbHVhdGVkIGJhc2VkIG9uIGNoYW5nZXMgdG8gdGhlIGxhbmd1YWdlIGFuZFxuICAgICAgICAvLyBjb21tb24gZGV2ZWxvcG1lbnQgcHJhY3RpY2VzLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlIHRoZSBjb25maWd1cmF0aW9uIG9iamVjdCB1c2VkIGZvciBidWlsZGluZyBjb21wYXJhdG9ycy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yQ29uZmlnKHsgY2lyY3VsYXIsIGNyZWF0ZUN1c3RvbUNvbmZpZywgc3RyaWN0LCB9KSB7XG4gICAgbGV0IGNvbmZpZyA9IHtcbiAgICAgICAgYXJlQXJyYXlCdWZmZXJzRXF1YWwsXG4gICAgICAgIGFyZUFycmF5c0VxdWFsOiBzdHJpY3QgPyBhcmVPYmplY3RzRXF1YWxTdHJpY3QgOiBhcmVBcnJheXNFcXVhbCxcbiAgICAgICAgYXJlRGF0YVZpZXdzRXF1YWwsXG4gICAgICAgIGFyZURhdGVzRXF1YWw6IGFyZURhdGVzRXF1YWwsXG4gICAgICAgIGFyZUVycm9yc0VxdWFsOiBhcmVFcnJvcnNFcXVhbCxcbiAgICAgICAgYXJlRnVuY3Rpb25zRXF1YWw6IGFyZUZ1bmN0aW9uc0VxdWFsLFxuICAgICAgICBhcmVNYXBzRXF1YWw6IHN0cmljdCA/IGNvbWJpbmVDb21wYXJhdG9ycyhhcmVNYXBzRXF1YWwsIGFyZU9iamVjdHNFcXVhbFN0cmljdCkgOiBhcmVNYXBzRXF1YWwsXG4gICAgICAgIGFyZU51bWJlcnNFcXVhbDogYXJlTnVtYmVyc0VxdWFsLFxuICAgICAgICBhcmVPYmplY3RzRXF1YWw6IHN0cmljdCA/IGFyZU9iamVjdHNFcXVhbFN0cmljdCA6IGFyZU9iamVjdHNFcXVhbCxcbiAgICAgICAgYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbDogYXJlUHJpbWl0aXZlV3JhcHBlcnNFcXVhbCxcbiAgICAgICAgYXJlUmVnRXhwc0VxdWFsOiBhcmVSZWdFeHBzRXF1YWwsXG4gICAgICAgIGFyZVNldHNFcXVhbDogc3RyaWN0ID8gY29tYmluZUNvbXBhcmF0b3JzKGFyZVNldHNFcXVhbCwgYXJlT2JqZWN0c0VxdWFsU3RyaWN0KSA6IGFyZVNldHNFcXVhbCxcbiAgICAgICAgYXJlVHlwZWRBcnJheXNFcXVhbDogc3RyaWN0XG4gICAgICAgICAgICA/IGNvbWJpbmVDb21wYXJhdG9ycyhhcmVUeXBlZEFycmF5c0VxdWFsLCBhcmVPYmplY3RzRXF1YWxTdHJpY3QpXG4gICAgICAgICAgICA6IGFyZVR5cGVkQXJyYXlzRXF1YWwsXG4gICAgICAgIGFyZVVybHNFcXVhbDogYXJlVXJsc0VxdWFsLFxuICAgICAgICB1bmtub3duVGFnQ29tcGFyYXRvcnM6IHVuZGVmaW5lZCxcbiAgICB9O1xuICAgIGlmIChjcmVhdGVDdXN0b21Db25maWcpIHtcbiAgICAgICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCBjcmVhdGVDdXN0b21Db25maWcoY29uZmlnKSk7XG4gICAgfVxuICAgIGlmIChjaXJjdWxhcikge1xuICAgICAgICBjb25zdCBhcmVBcnJheXNFcXVhbCA9IGNyZWF0ZUlzQ2lyY3VsYXIoY29uZmlnLmFyZUFycmF5c0VxdWFsKTtcbiAgICAgICAgY29uc3QgYXJlTWFwc0VxdWFsID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlTWFwc0VxdWFsKTtcbiAgICAgICAgY29uc3QgYXJlT2JqZWN0c0VxdWFsID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlT2JqZWN0c0VxdWFsKTtcbiAgICAgICAgY29uc3QgYXJlU2V0c0VxdWFsID0gY3JlYXRlSXNDaXJjdWxhcihjb25maWcuYXJlU2V0c0VxdWFsKTtcbiAgICAgICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnLCB7XG4gICAgICAgICAgICBhcmVBcnJheXNFcXVhbCxcbiAgICAgICAgICAgIGFyZU1hcHNFcXVhbCxcbiAgICAgICAgICAgIGFyZU9iamVjdHNFcXVhbCxcbiAgICAgICAgICAgIGFyZVNldHNFcXVhbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWc7XG59XG4vKipcbiAqIERlZmF1bHQgZXF1YWxpdHkgY29tcGFyYXRvciBwYXNzLXRocm91Z2gsIHVzZWQgYXMgdGhlIHN0YW5kYXJkIGBpc0VxdWFsYCBjcmVhdG9yIGZvclxuICogdXNlIGluc2lkZSB0aGUgYnVpbHQgY29tcGFyYXRvci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxFcXVhbGl0eUNvbXBhcmF0b3IoY29tcGFyZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgX2luZGV4T3JLZXlBLCBfaW5kZXhPcktleUIsIF9wYXJlbnRBLCBfcGFyZW50Qiwgc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmUoYSwgYiwgc3RhdGUpO1xuICAgIH07XG59XG4vKipcbiAqIENyZWF0ZSB0aGUgYGlzRXF1YWxgIGZ1bmN0aW9uIHVzZWQgYnkgdGhlIGNvbnN1bWluZyBhcHBsaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSXNFcXVhbCh7IGNpcmN1bGFyLCBjb21wYXJhdG9yLCBjcmVhdGVTdGF0ZSwgZXF1YWxzLCBzdHJpY3QgfSkge1xuICAgIGlmIChjcmVhdGVTdGF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gaXNFcXVhbChhLCBiKSB7XG4gICAgICAgICAgICBjb25zdCB7IGNhY2hlID0gY2lyY3VsYXIgPyBuZXcgV2Vha01hcCgpIDogdW5kZWZpbmVkLCBtZXRhIH0gPSBjcmVhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwge1xuICAgICAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgICAgIGVxdWFscyxcbiAgICAgICAgICAgICAgICBtZXRhLFxuICAgICAgICAgICAgICAgIHN0cmljdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY2lyY3VsYXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbXBhcmF0b3IoYSwgYiwge1xuICAgICAgICAgICAgICAgIGNhY2hlOiBuZXcgV2Vha01hcCgpLFxuICAgICAgICAgICAgICAgIGVxdWFscyxcbiAgICAgICAgICAgICAgICBtZXRhOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgc3RyaWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBjYWNoZTogdW5kZWZpbmVkLFxuICAgICAgICBlcXVhbHMsXG4gICAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgICAgc3RyaWN0LFxuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcihhLCBiLCBzdGF0ZSk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZS5cbiAqL1xuY29uc3QgZGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoKTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUgYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXG4gKi9cbmNvbnN0IHN0cmljdERlZXBFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHsgc3RyaWN0OiB0cnVlIH0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIGRlZXBseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG4gKi9cbmNvbnN0IGNpcmN1bGFyRGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoeyBjaXJjdWxhcjogdHJ1ZSB9KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBkZWVwbHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLFxuICogYmFzZWQgb24gc3RyaWN0IGNvbXBhcmlzb24uXG4gKi9cbmNvbnN0IHN0cmljdENpcmN1bGFyRGVlcEVxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNpcmN1bGFyOiB0cnVlLFxuICAgIHN0cmljdDogdHJ1ZSxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZS5cbiAqL1xuY29uc3Qgc2hhbGxvd0VxdWFsID0gY3JlYXRlQ3VzdG9tRXF1YWwoe1xuICAgIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogKCkgPT4gc2FtZVZhbHVlWmVyb0VxdWFsLFxufSk7XG4vKipcbiAqIFdoZXRoZXIgdGhlIGl0ZW1zIHBhc3NlZCBhcmUgc2hhbGxvd2x5LWVxdWFsIGluIHZhbHVlIGJhc2VkIG9uIHN0cmljdCBjb21wYXJpc29uXG4gKi9cbmNvbnN0IHN0cmljdFNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBzdHJpY3Q6IHRydWUsXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiAoKSA9PiBzYW1lVmFsdWVaZXJvRXF1YWwsXG59KTtcbi8qKlxuICogV2hldGhlciB0aGUgaXRlbXMgcGFzc2VkIGFyZSBzaGFsbG93bHktZXF1YWwgaW4gdmFsdWUsIGluY2x1ZGluZyBjaXJjdWxhciByZWZlcmVuY2VzLlxuICovXG5jb25zdCBjaXJjdWxhclNoYWxsb3dFcXVhbCA9IGNyZWF0ZUN1c3RvbUVxdWFsKHtcbiAgICBjaXJjdWxhcjogdHJ1ZSxcbiAgICBjcmVhdGVJbnRlcm5hbENvbXBhcmF0b3I6ICgpID0+IHNhbWVWYWx1ZVplcm9FcXVhbCxcbn0pO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBpdGVtcyBwYXNzZWQgYXJlIHNoYWxsb3dseS1lcXVhbCBpbiB2YWx1ZSwgaW5jbHVkaW5nIGNpcmN1bGFyIHJlZmVyZW5jZXMsXG4gKiBiYXNlZCBvbiBzdHJpY3QgY29tcGFyaXNvbi5cbiAqL1xuY29uc3Qgc3RyaWN0Q2lyY3VsYXJTaGFsbG93RXF1YWwgPSBjcmVhdGVDdXN0b21FcXVhbCh7XG4gICAgY2lyY3VsYXI6IHRydWUsXG4gICAgY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yOiAoKSA9PiBzYW1lVmFsdWVaZXJvRXF1YWwsXG4gICAgc3RyaWN0OiB0cnVlLFxufSk7XG4vKipcbiAqIENyZWF0ZSBhIGN1c3RvbSBlcXVhbGl0eSBjb21wYXJpc29uIG1ldGhvZC5cbiAqXG4gKiBUaGlzIGNhbiBiZSBkb25lIHRvIGNyZWF0ZSB2ZXJ5IHRhcmdldGVkIGNvbXBhcmlzb25zIGluIGV4dHJlbWUgaG90LXBhdGggc2NlbmFyaW9zXG4gKiB3aGVyZSB0aGUgc3RhbmRhcmQgbWV0aG9kcyBhcmUgbm90IHBlcmZvcm1hbnQgZW5vdWdoLCBidXQgY2FuIGFsc28gYmUgdXNlZCB0byBwcm92aWRlXG4gKiBzdXBwb3J0IGZvciBsZWdhY3kgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IHN1cHBvcnQgZXhwZWN0ZWQgZmVhdHVyZXMgbGlrZVxuICogYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIG91dCBvZiB0aGUgYm94LlxuICovXG5mdW5jdGlvbiBjcmVhdGVDdXN0b21FcXVhbChvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGNpcmN1bGFyID0gZmFsc2UsIGNyZWF0ZUludGVybmFsQ29tcGFyYXRvcjogY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yLCBjcmVhdGVTdGF0ZSwgc3RyaWN0ID0gZmFsc2UsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGNvbmZpZyA9IGNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvckNvbmZpZyhvcHRpb25zKTtcbiAgICBjb25zdCBjb21wYXJhdG9yID0gY3JlYXRlRXF1YWxpdHlDb21wYXJhdG9yKGNvbmZpZyk7XG4gICAgY29uc3QgZXF1YWxzID0gY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yXG4gICAgICAgID8gY3JlYXRlQ3VzdG9tSW50ZXJuYWxDb21wYXJhdG9yKGNvbXBhcmF0b3IpXG4gICAgICAgIDogY3JlYXRlSW50ZXJuYWxFcXVhbGl0eUNvbXBhcmF0b3IoY29tcGFyYXRvcik7XG4gICAgcmV0dXJuIGNyZWF0ZUlzRXF1YWwoeyBjaXJjdWxhciwgY29tcGFyYXRvciwgY3JlYXRlU3RhdGUsIGVxdWFscywgc3RyaWN0IH0pO1xufVxuXG5leHBvcnQgeyBjaXJjdWxhckRlZXBFcXVhbCwgY2lyY3VsYXJTaGFsbG93RXF1YWwsIGNyZWF0ZUN1c3RvbUVxdWFsLCBkZWVwRXF1YWwsIHNhbWVWYWx1ZVplcm9FcXVhbCwgc2hhbGxvd0VxdWFsLCBzdHJpY3RDaXJjdWxhckRlZXBFcXVhbCwgc3RyaWN0Q2lyY3VsYXJTaGFsbG93RXF1YWwsIHN0cmljdERlZXBFcXVhbCwgc3RyaWN0U2hhbGxvd0VxdWFsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0T3duUHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5U3ltYm9scyIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwicHJvdG90eXBlIiwiY29tYmluZUNvbXBhcmF0b3JzIiwiY29tcGFyYXRvckEiLCJjb21wYXJhdG9yQiIsImlzRXF1YWwiLCJhIiwiYiIsInN0YXRlIiwiY3JlYXRlSXNDaXJjdWxhciIsImFyZUl0ZW1zRXF1YWwiLCJpc0NpcmN1bGFyIiwiY2FjaGUiLCJjYWNoZWRBIiwiZ2V0IiwiY2FjaGVkQiIsInNldCIsInJlc3VsdCIsImRlbGV0ZSIsImdldFNob3J0VGFnIiwidmFsdWUiLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsInVuZGVmaW5lZCIsImdldFN0cmljdFByb3BlcnRpZXMiLCJvYmplY3QiLCJjb25jYXQiLCJoYXNPd24iLCJwcm9wZXJ0eSIsImNhbGwiLCJzYW1lVmFsdWVaZXJvRXF1YWwiLCJQUkVBQ1RfVk5PREUiLCJQUkVBQ1RfT1dORVIiLCJSRUFDVF9PV05FUiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImtleXMiLCJhcmVBcnJheUJ1ZmZlcnNFcXVhbCIsImJ5dGVMZW5ndGgiLCJhcmVUeXBlZEFycmF5c0VxdWFsIiwiVWludDhBcnJheSIsImFyZUFycmF5c0VxdWFsIiwiaW5kZXgiLCJsZW5ndGgiLCJlcXVhbHMiLCJhcmVEYXRhVmlld3NFcXVhbCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJhcmVEYXRlc0VxdWFsIiwiZ2V0VGltZSIsImFyZUVycm9yc0VxdWFsIiwibmFtZSIsIm1lc3NhZ2UiLCJjYXVzZSIsInN0YWNrIiwiYXJlRnVuY3Rpb25zRXF1YWwiLCJhcmVNYXBzRXF1YWwiLCJzaXplIiwibWF0Y2hlZEluZGljZXMiLCJBcnJheSIsImFJdGVyYWJsZSIsImVudHJpZXMiLCJhUmVzdWx0IiwiYlJlc3VsdCIsIm5leHQiLCJkb25lIiwiYkl0ZXJhYmxlIiwiaGFzTWF0Y2giLCJtYXRjaEluZGV4IiwiYUVudHJ5IiwiYkVudHJ5IiwiYXJlTnVtYmVyc0VxdWFsIiwiYXJlT2JqZWN0c0VxdWFsIiwicHJvcGVydGllcyIsImlzUHJvcGVydHlFcXVhbCIsImFyZU9iamVjdHNFcXVhbFN0cmljdCIsImRlc2NyaXB0b3JBIiwiZGVzY3JpcHRvckIiLCJjb25maWd1cmFibGUiLCJlbnVtZXJhYmxlIiwid3JpdGFibGUiLCJhcmVQcmltaXRpdmVXcmFwcGVyc0VxdWFsIiwidmFsdWVPZiIsImFyZVJlZ0V4cHNFcXVhbCIsInNvdXJjZSIsImZsYWdzIiwiYXJlU2V0c0VxdWFsIiwidmFsdWVzIiwiYXJlVXJsc0VxdWFsIiwiaG9zdG5hbWUiLCJwYXRobmFtZSIsInByb3RvY29sIiwicG9ydCIsImhhc2giLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiJCR0eXBlb2YiLCJBUlJBWV9CVUZGRVJfVEFHIiwiQVJHVU1FTlRTX1RBRyIsIkJPT0xFQU5fVEFHIiwiREFUQV9WSUVXX1RBRyIsIkRBVEVfVEFHIiwiRVJST1JfVEFHIiwiTUFQX1RBRyIsIk5VTUJFUl9UQUciLCJPQkpFQ1RfVEFHIiwiUkVHX0VYUF9UQUciLCJTRVRfVEFHIiwiU1RSSU5HX1RBRyIsIlRZUEVEX0FSUkFZX1RBR1MiLCJVUkxfVEFHIiwidG9TdHJpbmciLCJjcmVhdGVFcXVhbGl0eUNvbXBhcmF0b3IiLCJ1bmtub3duVGFnQ29tcGFyYXRvcnMiLCJjb21wYXJhdG9yIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNBcnJheSIsIkRhdGUiLCJSZWdFeHAiLCJNYXAiLCJTZXQiLCJ0YWciLCJ0aGVuIiwidW5rbm93blRhZ0NvbXBhcmF0b3IiLCJzaG9ydFRhZyIsImNyZWF0ZUVxdWFsaXR5Q29tcGFyYXRvckNvbmZpZyIsImNpcmN1bGFyIiwiY3JlYXRlQ3VzdG9tQ29uZmlnIiwic3RyaWN0IiwiY29uZmlnIiwiYXNzaWduIiwiY3JlYXRlSW50ZXJuYWxFcXVhbGl0eUNvbXBhcmF0b3IiLCJjb21wYXJlIiwiX2luZGV4T3JLZXlBIiwiX2luZGV4T3JLZXlCIiwiX3BhcmVudEEiLCJfcGFyZW50QiIsImNyZWF0ZUlzRXF1YWwiLCJjcmVhdGVTdGF0ZSIsIldlYWtNYXAiLCJtZXRhIiwiZGVlcEVxdWFsIiwiY3JlYXRlQ3VzdG9tRXF1YWwiLCJzdHJpY3REZWVwRXF1YWwiLCJjaXJjdWxhckRlZXBFcXVhbCIsInN0cmljdENpcmN1bGFyRGVlcEVxdWFsIiwic2hhbGxvd0VxdWFsIiwiY3JlYXRlSW50ZXJuYWxDb21wYXJhdG9yIiwic3RyaWN0U2hhbGxvd0VxdWFsIiwiY2lyY3VsYXJTaGFsbG93RXF1YWwiLCJzdHJpY3RDaXJjdWxhclNoYWxsb3dFcXVhbCIsIm9wdGlvbnMiLCJjcmVhdGVDdXN0b21JbnRlcm5hbENvbXBhcmF0b3IiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/../../node_modules/fast-equals/dist/es/index.mjs\n");

/***/ })

};
;